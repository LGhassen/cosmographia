/*
 * $Revision$ $Date$
 *
 * Copyright by Astos Solutions GmbH, Germany
 *
 * This file is published under the Astos Solutions Free Public License
 * For details on copyright and terms of use see 
 * http://www.astos.de/Astos_Solutions_Free_Public_License.html
 */

#ifndef _VESTA_PARTICLE_EMITTER_H_
#define _VESTA_PARTICLE_EMITTER_H_

#include "InitialStateGenerator.h"
#include "../Object.h"
#include "../Spectrum.h"
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <vector>

namespace vesta
{

class ParticleRenderer;

/** A ParticleEmitter generates particles at a uniform rate over some
 *  specified time interval.
 *  
 *  Once the particle systems properties are initialized, particles are
 *  generated by calling the generateParticles() method with the current
 *  simulation time. The particle system described by a ParticleEmitter
 *  object is stateless: no state is maintained between calls to
 *  generateParticles. This keeps memory usage to a minimum, and more
 *  significantly that particles systems can be 'run' at any rate,
 *  even backwards.
 *
 *  The initial particle states are controlled by an InitialStateGenerator
 *  object. Various subclasses of InitialStateGenerator produce useful
 *  distributions of particle positions and velocities. In addition the
 *  emitter has a velocity variation parameter that can be adjusted to
 *  introduce an additional random factor for the velocity. Particle motions
 *  over time may be modified by a constant force vector. Setting the force
 *  to a non-zero vector will cause the particles to follow parabolic paths.
 *
 *  Particles also have properties that are purely dependent on the time
 *  elapsed since the particle was emitted, a value referred to as the
 *  age of the particle. Age-dependent properties are the size, color,
 *  and opacity. Particle size is linearly interpolated between the
 *  start and end valus over the lifetime of the particle. Color and
 *  opacity are computed by interpolating values in a small lookup
 *  table that can be modified with the setColor() method.
 *
 *  Examples:
 *
 *  A sphere of particles emerging from the origin. The velocity of the
 *  generator is zero, and it is solely the velocity variation factor
 *  that is reponsible for setting the particles on their paths:
 *  \code
 *  emitter->setGenerator(new PointGenerator(Vector3f::Zero(), Vector3f::Zero()));
 *  emitter->setVelocityVariation(1.0f);
 *  \endcode
 *
 *  Adding an initial velocity for the generator will produce a cone of
 *  particles:
 *  \code
 *  emitter->setGenerator(new PointGenerator(Vector3f::Zero(), Vector3f(0.0f, 0.0f, 1.0f)));
 *  emitter->setVelocityVariation(0.5f);
 *  \endcode
 *
 *  Adding a force will turn the cone into a particle fountain:
 *  \code
 *  emitter->setForce(Vector3f(0.0f, 0.0f, -0.3f));
 *  \endcode
 */
class ParticleEmitter : public Object
{
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW

    ParticleEmitter();
    ~ParticleEmitter();

    static const unsigned int MaxColors = 5;

    /** Properties of a generated particle
     */
    struct Particle
    {
        Eigen::Vector3f position;
        Eigen::Vector3f velocity;
        Eigen::Vector3f color;
        float opacity;
        float size;
    };

    void generateParticles(double simulationTime,
                           std::vector<Particle>& particleBuffer,
                           ParticleRenderer* renderer) const;

    /** Get the lifetime of a particle produced by this emitter.
     */
    double particleLifetime() const
    {
        return m_particleLifetime;
    }

    /** Set the lifetime for the particles produced by this emitter.
     */
    void setParticleLifetime(double particleLifetime)
    {
        m_particleLifetime = particleLifetime;
    }

    /** Get the number of particles produced per time unit by this
     *  emitter.
     */
    double spawnRate() const
    {
        return m_spawnRate;
    }

    /** Set the number of particles produced per time unit by this
     *  emitter.
     */
    void setSpawnRate(double spawnRate)
    {
        m_spawnRate = spawnRate;
    }

    double startTime() const
    {
        return m_startTime;
    }

    double endTime() const
    {
        return m_endTime;
    }

    /** Set the start and end times for the particle system. Equivalent
     *  to calling setStartTime() and setEndTime() in sequence.
     */
    void setTimeRange(double startTime, double endTime)
    {
        m_startTime = startTime;
        m_endTime = endTime;
    }

    /** Set the start time for the particle system. No particles
     *  will be visible at times prior to the startTime.
     */
    void setStartTime(double startTime)
    {
        m_startTime = startTime;
    }

    /** Set the end time for the particle system. No are particles
     *  are produced after the end time. At times after endTime +
     *  particleLifetime, no more particles will be visible.
     */
    void setEndTime(double endTime)
    {
        m_endTime = endTime;
    }

    /** Get the size of a particle when it's emitted.
      */
    float startSize() const
    {
        return m_startSize;
    }

    float endSize() const
    {
        return m_endSize;
    }

    /** Set the start and end sizes for particles.
      */
    void setSizeRange(float startSize, float endSize)
    {
        m_startSize = startSize;
        m_endSize = endSize;
    }


    /** Get the constant force affecting all particles produced by
     *  this emitter.
     */
    Eigen::Vector3f force() const
    {
        return m_force;
    }

    /** Set the constant force that affects all particles produced by
     *  this emitter.
     */
    void setForce(const Eigen::Vector3f& force)
    {
        m_force = force;
    }

    /** Set a specific color key. Index must be less than MaxColors.
      *
      * The following code will set create particles that change
      * from red to green and fade out as they age.
      *
      * \code
      * emitter->setColorCount(2);
      * emitter->setColor(0, Spectrum(1.0f, 0.0f, 0.0f), 1.0f);
      * emitter->setColor(1, Spectrum(0.0f, 1.0f, 0.0f), 0.0f);
      * \endcode
      */
    void setColor(unsigned int index, const Spectrum& color, float opacity)
    {
        if (index < MaxColors)
        {
            m_colorKeys[index].x() = color.red();
            m_colorKeys[index].y() = color.green();
            m_colorKeys[index].z() = color.blue();
            m_colorKeys[index].w() = opacity;
        }
    }

    /** Return the number of colors used in the color lookup table.
      */
    unsigned int colorCount() const
    {
        return m_colorCount;
    }

    /** Set the number of color keys used when computing the color
      * of a particle as it ages. The number of keys must be less than
      * MaxColors.
      */
    void setColorCount(unsigned int count)
    {
        if (count > 0 && count < MaxColors)
        {
            m_colorCount = count;
        }
    }


    /** Get the generator of random initial particle positions and
      * velocities.
      */
    InitialStateGenerator* generator() const
    {
        return m_generator.ptr();
    }

    /** Set the generator of random initial particle positions and
      * velocities.
      */
    void setGenerator(InitialStateGenerator* generator)
    {
        m_generator = generator;
    }


    /** Get the maximum variation in the initial particle velocity.
      */
    float velocityVariation() const
    {
        return m_velocityVariation;
    }

    /** Set the maximum variation in the initial particle velocity.
      */
    void setVelocityVariation(float variation)
    {
        m_velocityVariation = variation;
    }

    /** Get the trace length for particles. A non-zero trace length will
      * cause the particle appear stretched along the direction of its
      * velocity.
      */
    float traceLength() const
    {
        return m_traceLength;
    }

    /** Set the trace length for particles. A non-zero trace length will
      * cause the particle appear stretched along the direction of its
      * velocity. The length of the particle is the trace length multiplied
      * the by the current particle speed.
      */
    void setTraceLength(float traceLength)
    {
        m_traceLength = traceLength;
    }

    float boundingRadius() const;

    /** Return true if this emitter produces self-luminous particles.
      */
    bool isEmissive() const
    {
        return m_emissive;
    }

    /** Set whether the particles produced by this emitter are self-luminous.
      * By default, it is true; it should be set to false for particle systems
      * meant to simulate smoke and dust.
      */
    void setEmissive(bool emissive)
    {
        m_emissive = emissive;
    }

    /** Get the phase asymmetry parameter. The value of phase asymmetry controls
      * the way light is scattered by non-emissive particles. The default value of
      * 0 indicates isotropic scattering.
      *
      * \see Material::setPhaseAsymmetry
      */
    float phaseAsymmetry() const
    {
        return m_phaseAsymmetry;
    }

    /** Set the phase asymmetry parameter. The value of phase asymmetry controls
      * the way light is scattered by non-emissive particles. The default value of
      * 0 indicates isotropic scattering.
      *
      * \see Material::setPhaseAsymmetry
      */
    void setPhaseAsymmetry(float phaseAsymmetry)
    {
        m_phaseAsymmetry = phaseAsymmetry;
    }

private:
    counted_ptr<InitialStateGenerator> m_generator;

    double m_startTime;
    double m_endTime;
    double m_particleLifetime;
    double m_spawnRate; // number of particles per time unit

    Eigen::Vector3f m_force;

    // Particles are prevented from penetrating the blocking
    // plane.
    Eigen::Hyperplane<float, 3> m_blockingPlane;
    bool m_blockingPlaneEnabled;

    // Interpolated properties
    float m_startSize;
    float m_endSize;
    Eigen::Vector4f m_colorKeys[MaxColors];
    unsigned int m_colorCount;

    float m_velocityVariation;
    float m_traceLength;

    bool m_emissive;
    float m_phaseAsymmetry;
};

}

#endif // _VESTA_PARTICLE_EMITTER_H_
